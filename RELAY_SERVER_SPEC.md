# Claude Distill Relay Server — Implementation Specification

## 1. Overview

A **relay server** that enables sharing session distillation data across remote networks, not just within the same LAN.

### Core Principles
- The relay is a **dumb pipe** — it only forwards messages between two sides
- **E2E encryption is preserved** — the relay never knows the passphrase and cannot decrypt the payload
- Both sides connect to the relay **as clients** — no NAT/firewall issues

### Architecture

```
Sender                           Relay Server                    Receiver
  |                                  |                              |
  [1] TCP connect to relay           |                              |
  [2] CREATE_ROOM ──────────>   Create room                        |
      <────────── ROOM_CREATED (room_id)                            |
  [3] Display room_id to user        |                              |
      (waiting...)                   |                       [4] TCP connect to relay
                                     |                       [5] JOIN_ROOM ──────>
                              Pair receiver to room                  |
      <── PEER_JOINED ──────        |           ───── ROOM_JOINED ──>
      |                              |                              |
      |<══════ Existing protocol runs transparently through relay ══>|
      |                              |                              |
      ── CHALLENGE ─────────> [fwd] ── CHALLENGE ──────────────────>|
      |<── AUTH ────────────  [fwd] <── AUTH ───────────────────────|
      ── PAYLOAD ───────────> [fwd] ── PAYLOAD ────────────────────>|
      |<── ACK ─────────────  [fwd] <── ACK ───────────────────────|
      |                              |                              |
  [6] Wait for next receiver         |                        [7] Disconnect
      (repeat until Ctrl+C)          |
```

---

## 2. Relay Server Spec

### 2.1 Basics

| Item | Value |
|------|-------|
| Protocol | TCP (raw socket) |
| Port | Configurable, default `9784` |
| Message framing | 4-byte big-endian length prefix + UTF-8 JSON |
| Concurrency model | asyncio (Python) or any preferred language/framework |
| State storage | In-memory (resets on restart, no database required) |

### 2.2 Message Framing (same as existing protocol)

All messages use the following format:

```
[4 bytes: big-endian uint32 length][N bytes: UTF-8 JSON]
```

Python reference implementation:
```python
import struct, json

def send_msg(sock, obj: dict):
    data = json.dumps(obj).encode("utf-8")
    sock.sendall(struct.pack("!I", len(data)) + data)

def recv_msg(sock) -> dict | None:
    raw_len = recv_exact(sock, 4)
    if not raw_len:
        return None
    (length,) = struct.unpack("!I", raw_len)
    if length > 10 * 1024 * 1024:  # 10MB limit
        return None
    raw_body = recv_exact(sock, length)
    if not raw_body:
        return None
    return json.loads(raw_body.decode("utf-8"))
```

---

## 3. Relay Protocol Details

### 3.1 Room Creation (Sender → Relay)

**Request:**
```json
{
  "type": "CREATE_ROOM"
}
```

**Response (success):**
```json
{
  "type": "ROOM_CREATED",
  "room_id": "a7f3b2"
}
```

- `room_id`: **6-character alphanumeric code** generated by the relay (regenerate on collision)
- The room is bound to the sender's TCP connection

**Response (failure — e.g. server overloaded):**
```json
{
  "type": "ERROR",
  "reason": "too_many_rooms"
}
```

### 3.2 Room Join (Receiver → Relay)

**Request:**
```json
{
  "type": "JOIN_ROOM",
  "room_id": "a7f3b2"
}
```

**Response (success):**
```json
{
  "type": "ROOM_JOINED",
  "room_id": "a7f3b2"
}
```

Simultaneously sent to the Sender:
```json
{
  "type": "PEER_JOINED",
  "peer_id": "conn_xxxx"
}
```

**Response (failure):**
```json
{
  "type": "ERROR",
  "reason": "room_not_found"
}
```

### 3.3 Message Forwarding (Paired State)

Once a receiver joins a room, the relay **pairs** the two connections and forwards all subsequent messages to the other side as-is.

```
Sender ──[any message]──> Relay ──[forward as-is]──> Receiver
Sender <──[forward as-is]── Relay <──[any message]── Receiver
```

The relay does NOT interpret message contents. No JSON parsing needed — **forward raw bytes**.

Messages that actually flow during this phase (E2E between clients):
```
Sender → CHALLENGE  (passes through relay)  → Receiver
Sender ← AUTH       (passes through relay)  ← Receiver
Sender → PAYLOAD    (passes through relay)  → Receiver
Sender ← ACK        (passes through relay)  ← Receiver
```

### 3.4 After Receiver Disconnects

When the receiver disconnects after completing the ACK:
1. The relay notifies the sender:
```json
{
  "type": "PEER_DISCONNECTED",
  "peer_id": "conn_xxxx"
}
```
2. The sender's room **remains open** — other receivers can still JOIN_ROOM
3. When the sender disconnects, the room is deleted

### 3.5 Multiple Receivers

Multiple receivers connect to the same room **sequentially**:

```
Time →
Sender: ───── CREATE_ROOM ─── [wait] ── pair(R1) ── [relay] ── unpair ── [wait] ── pair(R2) ── ...
Receiver1:                               JOIN ─── CHALLENGE/AUTH/PAYLOAD/ACK ─── disconnect
Receiver2:                                                                        JOIN ─── ...
```

- If multiple receivers JOIN simultaneously, enqueue them in a **FIFO queue** and pair one at a time
- Alternatively (simpler): if already paired when a JOIN arrives, respond with `{"type": "ERROR", "reason": "room_busy"}` — client retries

---

## 4. Room Management Rules

| Rule | Description |
|------|-------------|
| **TTL** | Auto-delete room **30 minutes** after creation |
| **Sender disconnects** | Delete room immediately, send `ERROR` to any waiting receivers |
| **Max rooms** | **1000** per server (configurable) |
| **room_id format** | `[a-z0-9]{6}` — 6-char alphanumeric, ~2.1 billion combinations |
| **Message size limit** | **10MB** per single message |

---

## 5. Implementation Guide

### 5.1 Server State Model

```python
@dataclass
class Room:
    room_id: str
    sender_conn: Connection          # Sender's TCP connection
    receiver_conn: Connection | None # Currently paired receiver (None if waiting)
    created_at: float                # time.time()
    receiver_queue: asyncio.Queue    # Queued receiver connections

rooms: dict[str, Room] = {}         # room_id → Room
```

### 5.2 Main Loop (Pseudocode)

```python
async def handle_connection(reader, writer):
    # 1. Read the first message
    msg = await recv_msg(reader)

    if msg["type"] == "CREATE_ROOM":
        room_id = generate_room_id()
        rooms[room_id] = Room(room_id, conn, ...)
        await send_msg(writer, {"type": "ROOM_CREATED", "room_id": room_id})

        # Sender loop: pair with each receiver → relay → unpair
        while True:
            receiver = await room.receiver_queue.get()
            await send_msg(writer, {"type": "PEER_JOINED", "peer_id": ...})
            await relay_messages(sender=conn, receiver=receiver)
            await send_msg(writer, {"type": "PEER_DISCONNECTED", "peer_id": ...})

    elif msg["type"] == "JOIN_ROOM":
        room = rooms.get(msg["room_id"])
        if not room:
            await send_msg(writer, {"type": "ERROR", "reason": "room_not_found"})
            return
        await send_msg(writer, {"type": "ROOM_JOINED", "room_id": room_id})
        await room.receiver_queue.put(conn)
        # Block until relay_messages completes
```

### 5.3 Message Relay (Core Function)

```python
async def relay_messages(sender, receiver):
    """Bidirectional message forwarding. Terminates when either side disconnects."""

    async def forward(src_reader, dst_writer):
        while True:
            # Read 4-byte length prefix
            raw_len = await src_reader.readexactly(4)
            (length,) = struct.unpack("!I", raw_len)
            # Read message body
            raw_body = await src_reader.readexactly(length)
            # Forward as-is (no parsing needed)
            dst_writer.write(struct.pack("!I", length) + raw_body)
            await dst_writer.drain()

    try:
        await asyncio.gather(
            forward(sender_reader, receiver_writer),
            forward(receiver_reader, sender_writer),
        )
    except (asyncio.IncompleteReadError, ConnectionError):
        pass  # One side disconnected — normal termination
```

### 5.4 TTL Cleanup Task

```python
async def cleanup_expired_rooms():
    while True:
        await asyncio.sleep(60)
        now = time.time()
        expired = [rid for rid, room in rooms.items()
                   if now - room.created_at > 1800]  # 30 minutes
        for rid in expired:
            room = rooms.pop(rid)
            room.sender_conn.close()
```

---

## 6. Deployment

### 6.1 Minimum Requirements
- Python 3.10+ (or any preferred language)
- **No external libraries required** (stdlib only)
- Server with a public IP or port forwarding

### 6.2 Running

```bash
# Direct execution
python3 relay.py --port 9784

# Docker
docker run -p 9784:9784 claude-distill-relay

# systemd (optional)
[Unit]
Description=Claude Distill Relay Server

[Service]
ExecStart=/usr/bin/python3 /opt/relay/relay.py --port 9784
Restart=always

[Install]
WantedBy=multi-user.target
```

### 6.3 Environment Variables (Optional)

| Variable | Default | Description |
|----------|---------|-------------|
| `RELAY_PORT` | `9784` | Listening port |
| `RELAY_MAX_ROOMS` | `1000` | Maximum concurrent rooms |
| `RELAY_ROOM_TTL` | `1800` | Room TTL in seconds |
| `RELAY_MAX_MSG_SIZE` | `10485760` | Maximum message size in bytes |

---

## 7. Security Considerations

| Threat | Mitigation |
|--------|-----------|
| Relay reads payload | Impossible — AES-256-GCM E2E encryption, relay only forwards bytes |
| room_id brute force | 6-char alphanumeric = 2,176,782,336 combinations + 30min TTL + rate limiting recommended |
| DDoS / resource exhaustion | Max room limit + TTL + per-connection message size limit |
| Man-in-the-middle (MITM) | Relay is in MITM position, but challenge-response auth is E2E so forgery is impossible |
| TLS on relay (recommended) | Optional — wrapping in TLS also protects metadata (connecting IPs, etc.) |

### Optional Security Hardening
- **TLS**: Add TLS to the relay server via Let's Encrypt — prevents traffic pattern exposure
- **Rate limiting**: Limit connections per IP per minute (e.g. 10/min)
- **Auth tokens**: Require an API key to use the relay at all (for team-internal deployments)

---

## 8. Client-Side Changes (Reference)

After the relay server is implemented, the existing clients (`serve.py`, `receive.py`) will add a `--relay <host:port>` option.

**Sender changes summary:**
```
Current: Open TCP server + register mDNS + accept loop
Added:   When --relay → connect to relay + CREATE_ROOM + wait for PEER_JOINED + existing handshake
```

**Receiver changes summary:**
```
Current: mDNS discovery + TCP connect
Added:   When --relay → connect to relay + JOIN_ROOM + existing handshake
```

The rest (CHALLENGE → AUTH → PAYLOAD → ACK) remains **completely identical** — the relay forwards transparently.

---

## 9. Test Scenarios

### Basic Functionality
1. Start relay server → verify port is listening
2. Client A sends `CREATE_ROOM` → verify `room_id` received
3. Client B sends `JOIN_ROOM` → verify `ROOM_JOINED`, verify A receives `PEER_JOINED`
4. Verify bidirectional message forwarding (echo test)
5. B disconnects → verify A receives `PEER_DISCONNECTED`

### Multiple Receivers
6. After B disconnects, Client C joins same room_id → verify successful pairing

### Error Cases
7. `JOIN_ROOM` with non-existent room_id → verify `room_not_found`
8. Join attempt after room TTL expires → verify `room_not_found`
9. Sender disconnects → verify room is deleted
10. Exceed max room count → verify `too_many_rooms`

### E2E Integration (after client changes)
11. `serve.py --relay host:9784 "password"` → room_id displayed
12. `receive.py --relay host:9784 --room abc123 "password"` → distillation data received
13. Wrong passphrase → `DENIED` (rejected by sender, not relay)
